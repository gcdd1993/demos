# 第2章 Java并发机制的底层实现原理

## 2.1 volatile的应用

volatile是轻量级的synchronized,它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。

### 2.1.1 volatile的两条实现原则

1. Lock前缀指令会引起处理器缓存回写到内存。
2. 一个处理器的缓存回写到内存会导致其他处理器的缓存无效。

## 2.2 synchronized的实现原理与应用

在多线程并发编程中 synchronized一直是元老级角色,很多人都会称呼它为重量级锁。但是,随着 Java se1.6对 synchronized进行了各种优化之后,有些情况下它就并不那么重了。本文详细介绍 Java se1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁,以及锁的存储结构和升级过程。

先来看下利用synchronized实现同步的基础:Java中的每一个对象都可以作为锁。具体表现为以下3种形式。

- 对于普通同步方法,锁是当前实例对象。
- 对于静态同步方法,锁是当前类的Clas对象。
- 对于同步方法块,锁是 Synchonized括号里配置的对象。

### 2.2.2 锁的升级与对比

Java SE1.6为了减少获得锁和释放锁带来的性能消耗,引入了“偏向锁”和“轻量级锁”,在Java SE1.6中,锁一共有4种状态,级别从低到高依次是:**无锁状态**、**偏向锁状态**、**轻量级锁状态**和**重量级锁状态**,这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级,意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略,目的是为了提高获得锁和释放锁的效率。

#### 锁的优缺点对比

![](https://i.imgur.com/F3gGV3r.png)

## 2.3 原子操作的实现原理

原子(atomic)本意是“不能被进一步分割的最小粒子”,而原子操作( atomic operation)意为“不可被中断的一个或一系列操作”。

### 2.3.1 相关术语

![](https://i.imgur.com/gWMORFu.png)

### 2.3.2 处理器如何实现原子操作

当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。

处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。

- 通过总线锁保证原子性。

所谓总线锁就是使用处理器提供的一个LOCK#信号,当一个处理器在总线上输出此信号时,其他处理器的请求将被阻塞住,那么该处理器可以独占共享内存。

- 通过缓存锁定来保证原子性。

**但是有两种情况下处理器不会使用缓存锁定。**

1. 当操作的数据不能被缓存在处理器內部,或操作的数据跨多个缓存行(cache line)时,则处理器会调用总线锁定。
2. 有些处理器不支持缓存锁定。对于 Intel486和 Pentium处理器,就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。

### 2.3.3 JAVA如何实现原子操作

在Java中可以通过锁和循环CAS的方式来实现原子操作。

1. 使用循环CAS实现原子操作:循环进行CAS操作直到成功为止。

**【CAS实现原子操作的三大问题】**
- ABA问题

> 因为CAS需要在操作值的时候,检查值有没有发生变化,如果没有发生变化则更新,但是如果一个值原来是A,变成了B,又变成了A,那么使用CAS进行检查时会发现它的值没有发生变化,但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号,每次变量更新的时候把版本号加1,那么A→B→A就会变成1A→2B→3A。

- 循环时间长开销大

> 自旋CAS如果长时问不成功,会给CPU带来非常大的执行开销。如果JM能支持处理器提供的 pause指令,那么效率会有一定的提升。 pause指令有两个作用:第一，它可以延迟流水线执行指合(de- pipeline),使CPU不会消耗过多的执行资源,延迟的时间取决于具体实现的版本,在一些处理器上延迟时间是零;第二,它可以避免在退出循环的时候因內存顺序冲奕( Memory Order violation)而引起CPU流水线被清空( CPU Pipeline Flush),从而提高CPL的执行效率。

- 只能保证一个共享变量的原子操作

> 当对一个共享变量执行操作时,我们可以使用循环CAS的方式来保证原子操作,但是对多个共享变量操作时,循环CAS就无法保证操作的原子性,这个时候就可以用锁。还有一个取巧的办法,就是把多个共享变量合并成一个共享变量来操作。比如,有两个共享变量i=2,j=a,合并一下ij=2a,然后用CAS来操作i。从Java1.5开始JDK提供了 Atomic Reference类来保证引用对象之问的原子性,就可以把多个变量放在一个对象里来进行CAS操作

2. 使用锁机制实现原子操作:锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。





# 第3章 Java内存模型

1. Java內存模型的基础,主要介绍内存模型相关的基本概念;
2. Java內存模型中的顺序一致性,主要介绍重排序与顺序一致性內存模型;
3. 同步原语,主要介绍3个同步原语( synchronized、 volatile和 final)的内存语义及重排序规则在处理器中的实现;
4. Java內存模型的设计,主要介绍Java內存模型的设计原理,及其与处理器內存模型和顺序一致性內存模型的关系。

## 3.1 Java内存模型的基础

### 3.1.1 并发编程模型的两个关键问题

1. 线程之间如何通信
2. 线程之间如何同步

在命合式编程中,线程之间的通信机制有两种:共享內存和消息传递。

![](https://i.imgur.com/5dmUq7c.png)

### 3.1.2 Java内存模型的抽象结构

在Java中,所有实例域、静态域和数组元素都存储在堆內存中,堆內存在线程之间共享。

局部变量( Local Variables),方法定义参数(Java语言规范称之为 Formal method parameters)和异常处理器参数( Exception Handler parameters)不会在线程之间共享,它们不会有内存可见性问题,也不受内存模型的影响。

Java线程之间的通信由Java內存模型(本文简称为JMM)控制,JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看,JMM定义了线程和主内存之问的抽象关系:线程之间的共享变量存储在主内存( Main Memory)中,每个线程都有一个私有的本地内存( Local memory),本地内存中存储了该线程以读写共享变量的副本。本地内存是JMM的个抽象概念,并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。

![](https://i.imgur.com/xlyepa6.png)

从图3-1来看,如果线程A与线程B之间要通信的话,必须要经历下面2个步骤
1. 线程A把本地内存A中更新过的共享变量刷新到主内存中去。
2. 线程B到主内存中去读取线程A之前已更新过的共享变量。

![](https://i.imgur.com/9hTttBh.png)

从整体来看,这两个步骤实质上是线程A在向线程B发送消息,而且这个通信过程必须要经过主內存。JMM通过控制主内存与每个线程的本地內存之问的交互,来为Java程序员提供内存可见性保证。

### 3.1.3 从源代码到指令序列的重排序

在执行程序时,为了提高性能,编译器和处理器常常会对指合做重排序。重排序分3种类型。

1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下,可以重新安排语句的执行顺序。
2. 指令级并行的重排序。现代处理器采用了指爷级并行技术( Instruction-Level Parallelism,ILP)来将多条指令重叠执行。如果不存在数据依赖性,处理器可以改变语句对应机器指合的执行顺序。
3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区,这使得加载和存储操作看上去可能是在乱序执行。

![](https://i.imgur.com/r9B1Eui.png)

### 3.1.4 并发编程模型的分类

现代的处理器使用写缓冲区临时保存向內存写入的数据。写缓冲区可以保证指命流水线持续运行,它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时,通过以批处理的方式刷新写缓冲区,以及合并写缓冲区中对同一内存地址的多次写,减少对内存总线的占用。虽然写缓冲区有这么多好处,但每个处理器上的写缓冲区,仅仅对它所在的处理器可见。这个特性会对內存操作的执行顺序产生重要的影响:处理器对内存的读写操作的执行顺序,不一定与內存实际发生的读写操作顺序一致!

![](https://i.imgur.com/N9VnKmg.png)

这里处理器A和处理器B可以同时把共享变量写入自己的写缓冲区(A1,B1),然后从内存中读取另一个共享变量(A2,B2),最后扌把自己写缓存区中保存的脏数据刷新到内存中(A3,B3)。当以这种时序执行时,程序就可以得到x=y=0的结果。

从內存操作实际发生的顺序来看,直到处理器A执行A3来刷新自己的写缓存区,写操作Al才算真正执行了。虽然处理器A执行內存操作的顺序为:Al→A2,但内存操作实际发生的顺序却是A2→Al。此时,处理器A的內存操作顺序被重排序了(处理器B的情况和处理器A一样,这里就不赘述了)

### 3.1.5 happens-before简介

定义：the first is visible to and ordered before the second（前一个操作(执行的结果)对后一个操作可见,且前一个操作按顺序排在第二个操作之前）

与程序员密切相关的 Happens-before规则如下：

- 程序顺序规则:一个线程中的每个操作, happens-before于该线程中的任意后续操作。
- 监视器锁规则:对一个锁的解锁, happens-before于随后对这个锁的加锁。
- volatile变量规则:对一个 volatile域的写, happens- before于任意后续对这个 volatile域的读。
- 传递性:如果 A happens-before B,且 B happens-before C,那么 A happens-before C。

![](https://i.imgur.com/GvVNcrA.png)

一个 happens-before规则对应于一个或多个编译器和处理器重排序规则。对Java程序员来说, happens-before规则简单易懂,它避免Java程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法。

## 3.2 重排序

重排序是指编译器和处理器为了优化程序性能而对指爷序列进行重新排序的一种手段。

### 3.2.1 数据依赖性

如果两个操作访问同一个变量,且这两个操作中有一个为写操作,此时这两个操作之间就存在数据依赖性。数据依赖分为下列3种类型:

![](https://i.imgur.com/MhJecRY.png)

上面3种情况,只要重排序两个操作的执行顺序,程序的执行结果就会被改变。

前面提到过,编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时,会遵守数据依赖性,**编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。**

这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。

### 3.2.2 as-if-serial语义

as-if- serial语义的意思是:不管怎么重排序(编译器和处理器为了提高并行度),(单线程)程序的执行结果不能被改变。编译器、 runtime和处理器都必须遵守as- if-serial语义。

为了遵守as-if-serial语义,编译器和处理器不会对存在数据依赖关系的操作做重排序,因为这种重排序会改变执行结果。但是,如果操作之间不存在数据依赖关系,这些操作就可能被编译器和处理器重排序。为了具体说明,请看下面计算圆面积的代码示例

	double pi = 3.14;         //A
	double r = 1.0; 		  //B
	double area = pi * r * r  //C

![](https://i.imgur.com/ZEFZCSH.png)

如图3-6所示,A和C之间存在数据依赖关系,同时B和C之间也存在数据依赖关系。因此在终执行的指爷序列中,C不能被重排序到A和B的前面C排到A和B的前面,程序的结果将会被改变)。但A和B之间没有数据依赖关系,编译器和处理器可以重排序A和B之问的执行顺序。

as-if-serial语义把单线程程序保护了起来,遵守as- if-serial语义的编译器、 runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉:单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会干扰他们,也无需担心內存可见性问题。

### 3.2.3 程序顺序规则

根据 happens-before的程序顺序规则,上面计算圆的面积的示例代码存在3个happens-before关系：

1. A happens-before B
2. B happens-before C
3. A happens-before C

这里的第3个 happens- before关系,是根据 happens- before的传递性推导出来的。

这里 A happens- before B,但实际执行时B却可以排在A之前执行(看上面的重排序后的执行顺序)。如果 A happens- before B,JMM并不要求A一定要在B之前执行。JMM仅仅要求前一个操作(执行的结果〕对后一个操作可见,且前一个操作按顺序排在第二个操作之前。这里操作A的执行结果不需要对操作B可见;而且重排序操作A和操作B后的执行结果,与操作A和操作B按 happens- before顺序执行的结果一致。在这种情况下,JMM会认为这种重排序并不非法(not illegal),JMM允许这种重排序。

在计算机中,软件技术和硬件技术有一个共同的目标:在不改变程序执行结果的前提下尽可能提高并行度。编译器和处理器遵从这一目标,从happens-before的定义我们可以看出JMM同样遵从这一目标。






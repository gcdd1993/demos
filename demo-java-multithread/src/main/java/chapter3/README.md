# 第三章 线程间通信

线程是操作系统中独立的个体,但这些个体如果不经过特殊的处理就不能成为一个整
体。线程间的通信就是成为整体的必用方案之一,可以说,使线程间进行通信后,系统之间
的交互性会更强大,在大大提高CPU利用率的同时还会使程序员对各线程任务在处理的过
程中进行有效的把控与监督。在本章中需要着重掌握的技术点如下:

- 使用 wait/notify实现线程间的通信。
- 生产者/消费者模式的实现
- 方法join的使用。
- Threadlocal类的使用。

## 3.1 等待/通知机制

本节将介绍多个线程之间进行通信,通过本节的学习可以了解到。线程与线程之间不是
独立的个体,它们彼此之间可以互相通信和协作。

### 3.1.1 不使用等待/通知机制实现线程间通信

[实例代码-twoThreadTransData](https://github.com/qq1398371419/Java-Multi-thread-Programming/tree/master/src/main/java/chapter3/twoThreadTransData)

虽然两个线程间实现了通信,但有个弊端就是,线程 Thread.java不停地通过 while语句轮询机制来检测某一个条件,这样会浪费CPU资源。
如果轮询的时间间隔很小,更浪费CPU资源;如果轮询的时间间隔很大,有可能会取不到想要得到的数据。所以就需要有一种机制来实现减少CPU的资源浪费,而且
还可以实现在多个线程间通信,它就是“ wait/notify”机制。

### 3.1.2 什么是等待/通知机制

等待/通知机制在生活中比比皆是,比如在就餐时就会出现,如图3-2所示。
厨师和服务员之间的交互要在“菜品传递台”上,在这期间会有几个问题:

![](https://i.imgur.com/ifai1JE.png)

1. 厨师做完一道菜的时间不确定,所以厨师将菜品放到“菜品传递台”上的时间也不确定。
2. 服务员取到菜的时间取决于厨师,所以服务员就有“等待”(wait)的状态。
3. 服务员如何能取到菜呢?这又得取决于厨师,厨师将菜放在“菜品传递台”上,其实就相当于一种通知(notify),这时服务员才可以拿到菜并交给就餐者。
4. 在这个过程中出现了“等待/通知”机制。

需要说明的是,前面章节中多个线程之间也可以实现通信,原因就是多个线程共同访问
同一个变量,但那种通信机制不是“等待/通知”,两个线程完全是主动式地读取一个共享变
量,在花费读取时间的基础上,读到的值是不是想要的,并不能完全确定。所以现在迫切需
要一种“等待/通知”机制来满足上面的需求。

### 3.1.3 等待/通知机制的实现

wait（等待） 和 notify（通知） 几个要牢记的概念：

1. wait 使当前执行代码的线程进行等待 
   notify 用来通知那些可能等待该对象的对象锁的其他线程
2. 调用wait或notify方法前，线程必须获得该对象的对象级别锁,即只
能在同步方法或同步块中调用wait0方法。
3. 在执行 notify方法后,当前线程不会马上释放该对象锁,呈wait状态
的线程也并不能马上获取该对象锁,要等到执行 notify方法的线程将程序执行完,也就是退出synchronized代码块后,当前线程才会释放锁,而呈wait状态所在的线程才可以获取该对象锁。

用一句话来总结一下wait和notify : wait使线程停止运行,而notify使停止的线程继续运行。

【线程的状态切换】
![](https://i.imgur.com/ysgxjHL.png)

1. 新创建一个新的线程对象后,再调用它的start()方法,系统会为此线程分配CPU资
源,使其处于Runnable (可运行)状态,这是一个准备运行的阶段。如果线程抢占到CPU资,
源,此线程就处于Running (运行)状态。

2. Runnable状态和Running状态可相互切换,因为有可能线程运行一段时间后,有其
他高优先级的线程抢占了CPU资源,这时此线程就从Running状态变成Runnable状态。
线程进入Runnable状态大体分为如下5种情况:

	- 调用sleep()方法后经过的时间超过了指定的休眠时间。
	- 线程调用的阻塞IO已经返回,阻塞方法执行完毕。
	- 线程成功地获得了试图同步的监视器。
	- 线程正在等待某个通知,其他线程发出了通知。
	- 处于挂起状态的线程调用了resume恢复方法。

3. Blocked是阻塞的意思,例如遇到了一个IO操作,此时CPU处于空闲状态,可能会,转而把CPU时间片分配给其他线程,这时也可以称为"暂停"状态。Blocked状态结束后,进入Runnable状态,等待系统重新分配资源。出现阻塞的情况大体分为如下5种:

	- 线程调用sleep方法,主动放弃占用的处理器资源。
	- 线程调用了阻塞式IO方法,在该方法返回前,该线程被阻塞。
	- 线程试图获得一个同步监视器,但该同步监视器正被其他线程所持有。
	- 线程等待某个通知。
	- 程序调用了suspend方法将该线程挂起。此方法容易导致死锁,尽量避免使用该方法。

4. run()方法运行结束后进入销毁阶段,整个线程执行完毕。

每个锁对象都有两个队列,一个是就绪队列,一个是阻塞队列。就绪队列存储了将要获得锁的线程,阻塞队列存储了被阻塞的线程。一个线程被唤醒后,才会进入就绪队列,等待CPU的调度;反之,一个线程被wait后,就会进入阻塞队列,等待下一次被唤醒。

### 3.1.4 方法wait()锁释放与notify()锁不释放

当方法wait()被执行后,锁被自动释放,但执行完notify()方法,锁却不自动释放。

### 3.1.5 当interrupt方法遇到wait方法

当线程呈wait()状态时,调用线程对象的interrupt()方法会出现InterruptedException异常。

### 3.1.6 只通知一个线程

调用方法notify()一次只随机通知一个线程进行唤醒。

### 3.1.7 唤醒所有线程

前面示例中通过多次调用notify()方法来实现唤醒3个线程,但并不能保证系统中仅有
3个线程,也就是若notify()方法的调用次数小于线程对象的数量,会出现有部分线程对象无
法被唤醒的情况。为了唤醒全部线程,可以使用notifyAll()方法。

### 3.1.8 方法wait(long)的使用
带一个参数的wait(long)方法的功能是等待某一时间内是否有线程对锁进行唤醒,如果超过这个时间则自动唤醒。

### 3.1.9 使用wait & notify的坑

- 通知过早：如果通知过早,则会打乱程序正常的运行逻辑。
- 等待wait的条件发生变化：也会打乱程序正常的运行逻辑。

### 3.1.11 生产者/消费者模式实现

等待/通知模式最经典的案例就是“生产者/消费者”模式。但此模式在使用上有几种“变形”,还
有一些小的注意事项,但原理都是基于wait/notify的。

### 3.1.12 通过管道进行线程间通信:字节流

在Java语言中提供了各种各样的输入/输出流Stream,使我们能够很方便地对数据进行操作,其中管道流(pipeStream)是一种特殊的流,用于在不同线程间直接传送数据。一个线程发送数据到输出管道,另一个线程从输入管道中读数据。通过使用管道,实现不同线程间的通信,而无须借助于类似临时文件之类的东西。

在Java的JDK中提供了4个类来使线程间可以进行通信:
1) PipedInputStream和PipedOutputStream
2) PipedReader和PipedWriter

## 3.2 方法join的使用

在很多情况下,主线程创建并启动子线程,如果子线程中要进行大量的耗时运算,主线程往往将早于子线程结束之前结束。这时,如果主线程想等待子线程执行完成之后再结束,比如子线程处理一个数据,主线程要取得这个数据中的值,就要用到join()方法了。方法join()的作用是等待线程对象销毁。

### 3.2.5 方法join(long)与sleep(long)的区别

方法join(long)的功能在内部是使用wait(long)方法来实现的,所以join(long)方法具有释放锁的特点。

从源代码中可以了解到,当执行wait(long)方法后,当前线程的锁被释放,那么其他线程就可以调用此线程中的同步方法了。而Thread.sleep(long)方法却不释放锁。

## 3.3类ThreadLocal的使用

变量值的共享可以使用public static变量的形式,所有的线程都使用同一个public static变量。如果想实现每一个线程都有自己的共享变量该如何解决呢? JDK中提供的类,ThreadLocal正是为了解决这样的问题。

类ThreadLocal主要解决的就是每个线程绑定自己的值,可以将ThreadLocal类比喻成全局存放数据的盒子,盒子中可以存储每个线程的私有数据。







